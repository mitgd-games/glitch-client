package com.reversefold.glitch.server.player {
    import com.reversefold.glitch.server.Common;
    import com.reversefold.glitch.server.data.Config;
    import com.reversefold.glitch.server.player.Player;

    import org.osmf.logging.Log;
    import org.osmf.logging.Logger;

    public class Party extends Common {
        private static var log : Logger = Log.getLogger("server.player.party");

        public var config : Config;
        public var player : Player;

        public function Party(config : Config, player : Player) {
            this.config = config;
            this.player = player;
        }


//
// invite someone to join our party
//

public function party_invite(pc, silent){

    if (!this.has_done_intro){
        return false;
    }

    //
    // make sure we're in a party.
    // if we're not, create an ephemeral one
    //

    var created = false;

    if (!this.party){

        created = true;
        this.party_create();
    }


    //
    // invite
    //

    var ret = this.party.send_invite(this, pc, silent);

    if (ret != 'ok' && created){

        log.info('XX destroying after sending invite...');

        this.party.leave(this, 'invites-done');
    }


    //
    // messaging
    //

    switch (ret){
        case 'invited':
            this.party_activity(utils.escape(pc.label)+" has already been invited to join your party.");
            break;
        case 'offline':
            this.party_activity(utils.escape(pc.label)+" is currently offline.");
            break;
        case 'other_party':
            this.party_activity(utils.escape(pc.label)+" is already in a party.");
            break;
        case 'full':
            this.party_activity("Your party is full!");
            break;
        case 'kicked':
            this.party_activity(utils.escape(pc.label)+" has been removed from your party - only the party creator can re-invite them.");
            break;
        case 'newxp':
            this.party_activity(utils.escape(pc.label)+" cannot yet join your party.");
            break;
        case 'ok':
            this.party_activity("You have invited "+utils.escape(pc.label)+" to join your party.");
            break;
        default:
            this.party_activity("Unknown invite response: "+ret);
    }

    return ret;
}

//
// leave our current party
//

public function party_leave(){

    //log.info(this.tsid+'.party_leave()');

    if (this.party) this.party.leave(this, 'left');
}


//
// are we in a party?
//

public function party_is_in(){

    return this.party ? true: false;
}

public function party_get(){
    return this.party;
}

public function party_is_full(){
    return this.party && this.party.is_full();
}


//
// we have been invited to join a party. show
// invitation and maybe join.
//

public function party_invited(party, inviter){

    var txt = utils.escape(inviter.label)+" has invited you to join their ";

    var space = party.get_space();
    if (space){
        var loc = apiFindObject(space.get_entrance());
        if (loc){
            txt += "Party in "+utils.escape(loc.label)+".";
        }
        else{
            txt += "Party Chat.";
        }
    }
    else{
        txt += "Party Chat.";
    }

    this.player.prompts.prompts_add({
        callback    : 'familiar_invite_read',
        party       : party,
        inviter     : inviter,
        txt     : txt,
        timeout     : config.party_invite_timeout-1,
        icon_buttons    : true,
        choices     : [
            { label : 'OK', value: 'accept' },
            { label : 'No thanks', value: 'decline' }
        ]
    });
}

public function familiar_invite_read(choice, details){

    if (choice == 'accept'){
        details.inviter.party_invite_accepted(this);
    }

    if (choice == 'decline'){
        details.inviter.party_invite_declined(this);
    }
}


//
// somebody we invited has responded. these functions
// proxy to our *current* group, to allow the group to
// change while the invite is outstanding
//

public function party_invite_accepted(pc, auto_space){
    if (!this.party) this.party_create();
    this.party.accept_invite(pc, this, auto_space);
}

public function party_invite_declined(pc){
    if (!this.party) this.party_create();
    this.party.decline_invite(pc, this);
}


//
// our party invite has expired
//

public function party_uninvited(party, inviter){

    // TODO: remove any invites from this player from the familiar queue

    this.party_activity('Your invite from '+utils.escape(inviter.label)+' to join their party has expired');
}


//
// we are no longer in a party
//

public function party_left(reason){

    //log.error('party_left for '+this.tsid);

    delete this.party;

    switch (reason){
        case 'disband':
            this.apiSendMsg({ type :'party_leave' });
            this.party_activity("Your party has been disbanded");
            break;
        case 'invites-done':
            // the party was only emphemeral, being used for invites
            break;
        case 'left':
            this.apiSendMsg({ type :'party_leave' });
            this.party_activity("You have left the party");
            break;
        case 'offline':
            // everyone went offline
            break;
        default:
            this.apiSendMsg({ type :'party_leave' });
            this.party_activity("Left party for unknown reason: "+reason);
    }

    //this.player.sendActivity('MSG:party_leave');
}


//
// we're now the leader of the party
//

public function party_now_leader(){

    this.party_activity('now leader of party');
}


//
// we have joined a party
//

public function party_joined(party, reason, pc){

    //log.error("party_joined for "+this.tsid);

    this.party = party;

    var m = party.get_members();

    //this.player.sendActivity('MSG:party_join');
    this.apiSendMsg({
        type    : 'party_join',
        members : m
    });

    if (reason == 'invite_accepted'){

        this.party_activity(utils.escape(pc.label)+' accepted your party invite.');

    }else{

        var m_names = [];
        for (var i in m){
            if (i != this.tsid){
                m_names.push(utils.escape(m[i].label));
            }
        }

        this.party_activity("You joined a party with "+pretty_list(m_names, ' and '));
    }
}


//
// some one declined our invite
//

public function party_declined(pc, expired){

    if (expired){
        this.party_activity(utils.escape(pc.label)+' has declined your invitation (expired)');
    }else{
        this.party_activity(utils.escape(pc.label)+' has declined your invitation');
    }
}


//
// someone else joined or left our party
//

public function party_member_joined(pc, invited){

    if (invited){
        this.party_activity(utils.escape(pc.label)+' accepted your party invite.');
    }else{
        this.party_activity(utils.escape(pc.label)+' has joined the party');
    }

    //this.player.sendActivity('MSG:party_add');
    this.apiSendMsg({
        type    : 'party_add',
        pc  : pc.make_hash_online()
    });
}

public function party_member_left(pc, reason){

    this.party_activity(utils.escape(pc.label)+" has left the party");

    //this.player.sendActivity('MSG:party_remove');
    this.apiSendMsg({
        type    : 'party_remove',
        pc_tsid : pc.tsid
    });
}


//
// party member changed online status
//

public function party_member_online(pc){

    this.party_activity("Party member "+utils.escape(pc.label)+" has come online");

    //this.player.sendActivity('MSG:party_online');
    this.apiSendMsg({
        type    : 'party_online',
        pc_tsid : pc.tsid
    });
}

public function party_member_offline(pc){

    this.party_activity("Party member "+utils.escape(pc.label)+" has gone offline");

    //this.player.sendActivity('MSG:party_offline');
    this.apiSendMsg({
        type    : 'party_offline',
        pc_tsid : pc.tsid
    });
}


//
// player going offline and coming online
//

public function party_logout(){

    if (this.party) this.party.player_logout(this);
}

public function party_login(){

    if (this.party) this.party.player_login(this);
}


//
// chatting
//

public function party_chat(txt){

    if (this.party){

        this.party.chat(this, txt);

        apiLogAction('CHAT_PARTY', 'pc='+this.tsid, 'party='+this.party.tsid, 'msg='+txt);
    }else{
        this.party_activity("You're not in a party!");
    }
}


//
// used for when we log in, to see if we're in a party the client needs to
// know about
//

public function party_members(){

    if (this.party){
        var m = this.party.get_members();
        if (num_keys(m) > 1) return m;
    }

    return null;
}


//
// remove & return any pending invites to the current party
// sent by us. used for moving invites to a new group with us.
//

public function party_get_invites_sent(){

    if (this.party) return this.party.remove_invites_from(this.tsid);

    return null;
}

/////////////////////////////////////////////////////////////////////////////////////////////

//
// Party Space code
//

public function party_has_space(){
    if (this.party && this.party.get_space()) return true;
}

public function party_start_space(template, duration){
    if (!this.party) return {ok: 0, error: "You are not in a party."};
    if (this.party_has_space()) return {ok: 0, error: "There's already a space!"};

    this.party.create_space(template, duration, this);

    return {ok: 1};
}

public function party_enter_space(){
    if (!this.party) return {ok: 0, error: "You are not in a party."};

    if (this.party.enter_space(this)){
        return {ok: 1};
    }
    else{
        return {ok: 0, error: "Could not enter the space."};
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////

//
// private API below here
//


//
// create a new party with just us in it
//

public function party_create(){

    //log.error('party_create for '+this.tsid);

    this.party = apiNewGroup('party');

    this.party.init(this);
}


//
// send a party activity notice
//

public function party_activity(msg){

    this.player.sendMsgOnline({
        type: 'party_activity',
        txt: msg
    });
}

public function party_space_prompt(){
    if (!this.party) return;

    var ret = this.party.get_space_details();
    var pcs = [];
    for (var i in ret.players){
        pcs.push(ret.players[i].make_hash());
    }

    var energy_cost = this.player.teleportation.teleportation_get_energy_cost();
    if (!energy_cost) energy_cost = Math.round(this.player.metabolics.metabolics_get_max_energy() * 0.40);
    this.apiSendMsg({
        type: 'party_space_start',
        location_name: ret.label,
        img_url: ret.img_url,
        desc: ret.desc,
        pcs: pcs,
        energy_cost: energy_cost
    });
}

public function party_space_prompt_callback(choice, details){
    if (!this.party || !this.party.get_space()) {
        this.player.sendActivity("Sorry, but the party space has already expired.");
        return;
    }

    if (choice == 'energy'){
        var energy_cost = this.player.teleportation.teleportation_get_energy_cost();
        if (!energy_cost) energy_cost = Math.round(this.player.metabolics.metabolics_get_max_energy() * 0.40);

        if (this.player.metabolics.metabolics_try_lose_energy(energy_cost)){
            this.party_create_teleporter();
        }
        else{
            this.player.sendActivity("You don't have enough energy for that.");
            this.party_space_prompt();
        }
    }
    else if (choice == 'token'){
        if (this.player.teleportation.teleportation_spend_token("Party Space teleportation.")){
            this.party_create_teleporter();
        }
        else{
            this.player.sendActivity("You don't have any tokens left.");
            this.party_space_prompt();
        }
    }
    else{
        this.party_activity("If you'd like to join the Party Space later, you can do so from the Party Chat menu above.");
    }
}

public function party_create_teleporter(){
    //log.info(this+' Creating party teleporter');
    var tp = this.location.createAndReturnItem('teleporter_visible', 1, this.x+100, this.y+40, 0, this.tsid);
    if (tp){
        this.player.announcements.announce_sound('TELEPORTER_VISIBLE_APPEAR');
        this.player.announcements.announce_sound_delayed('TELEPORTER_VISIBLE_PORTAL', 0, 0, 1);
        //log.info(this+' Teleporter is '+tp);
        tp.setInstanceProp('width', 50);
        tp.setInstanceProp('height', 200);
        tp.setInstanceProp('single_use', 1);
        tp.setInstanceProp('is_party', 1);
        tp.apiSetTimer('disappear', 2*60*1000);

        this.player.moveAvatar(tp.x-100, this.y, 'right');
    }
}

public function party_find_teleporter(){
    var is_tp = function(it, args){ return it.class_tsid == 'teleporter_visible' && it.only_visible_to == args; };

    var tp = this.location.find_items(is_tp, this.tsid)[0];
    if (tp){
        this.player.moveAvatar(tp.x, tp.y-40, 'right');
        return true;
    }

    return false;
}

public function party_extend_space_time(duration, cost){
    if (this.party){
        if (this.player.stats.stats_try_remove_currants(cost, {type: 'party_space_extend', party: this.party.tsid, space_type: this.party.get_space().getProp('party_template')})){
            this.party.extend_space_time(this, duration);
            return true;
        }

        return false;
    }

    return false;
}

    }
}
